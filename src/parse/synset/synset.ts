import cartesianProduct from '../../utils/cartesianProduct';
import { Lemma, Synset } from '../../core';
import {
  isAutogenerated,
  isDebatable,
  stripMetacharacters,
} from '../../utils/metacharacters';

type GroupItem = {
  index?: number;
  value: string;
};

export default function parseSynset(
  rawStr: string,
  isPhrase: boolean,
): Synset | null {
  const annotationsMap = new Map<string, string>();
  const meta = {
    autotranslated: isAutogenerated(rawStr),
    debatable: isDebatable(rawStr),
  };

  let str = stripMetacharacters(rawStr).trim();
  if (!str) {
    return null;
  }

  if (str.indexOf('(') >= 0) {
    let index = 0;
    str = str.replace(/\((\(*(?:[^)(]*|\([^)]*\))*\)*)\)/g, (_0, match) => {
      const key = `ANNOTATION_${index++}`;
      annotationsMap.set(key, match);
      return key;
    });
  }

  const lemmas = smartSplit(str, isPhrase).map<Lemma>((item) => {
    let value = item.value.trim();

    let annotation: string | undefined;
    if (annotationsMap.size > 0) {
      value = value.replace(/\s*(ANNOTATION_\d+)/g, function (_0, match) {
        annotation = annotationsMap.get(match);
        return '';
      });
    }

    const result: Lemma = {
      ...item,
      value: value.trim(),
    };

    if (annotation) {
      result.annotations = [annotation];
    }

    return result;
  });

  return {
    meta,
    options: lemmas.reduce<Lemma[]>((acc, lemma) => {
      const slashIndex = lemma.value.indexOf('/');
      if (slashIndex === -1) {
        return acc.concat(lemma);
      }

      const rawWords: string[] = lemma.value
        .replace(/\s*\/\s*/g, '/')
        .split(' ');

      const product: string[][] = cartesianProduct(
        rawWords.map((w) => w.split('/')),
      );

      return acc.concat(
        product.map((words) => ({
          ...lemma,
          value: words.join(' '),
        })),
      );
    }, []),
  };
}

function smartSplit(value: string, isPhrase: boolean): GroupItem[] {
  const hasSemicolon = value.indexOf(';') >= 0;
  const hasComma = value.indexOf(',') >= 0;

  if (isPhrase) {
    return value.split(';').map(toValue);
  }

  if (hasSemicolon && hasComma) {
    return value.split(';').map(semiColonGroupSplit).flat(1);
  }

  return value.split(hasComma ? ',' : ';').map(toValue);
}

function semiColonGroupSplit(words: string, index: number): GroupItem[] {
  const result: GroupItem[] = [];
  for (const value of words.split(',')) {
    result.push({ value, index });
  }

  return result;
}

function toValue(value: string): GroupItem {
  return { value };
}
