import { Annotation, Lemma, LemmaGroup, Synset } from '../../core';
import {
  isAutogenerated,
  isDebatable,
  stripMetacharacters,
} from '../../utils/metacharacters';

type ParseSynsetOptions = {
  isPhrase: boolean;
};

export default function parseSynset(
  rawStr: string,
  opts: ParseSynsetOptions,
): Synset {
  const synset = new Synset({
    autogenerated: isAutogenerated(rawStr),
    debatable: isDebatable(rawStr),
  });

  let str = stripMetacharacters(rawStr).trim();
  if (!str) {
    return synset;
  }

  const annotationsMap = new Map<string, string>();
  if (str.indexOf('(') >= 0) {
    let index = 0;
    str = str.replace(/\((\(*(?:[^)(]*|\([^)]*\))*\)*)\)/g, (_0, match) => {
      const key = `ANNOTATION_${index++}`;
      annotationsMap.set(key, match);
      return key;
    });
  }

  synset.groups = smartSplit(str, opts.isPhrase).reduce<LemmaGroup[]>(
    (acc, { value, index }) => {
      const group = (acc[index] = acc[index] || new LemmaGroup());

      let annotation: string | undefined;
      if (annotationsMap.size > 0) {
        value = value.replace(
          /\s*(ANNOTATION_\d+)/g,
          function (_0: unknown, match: string) {
            annotation = annotationsMap.get(match);
            return '';
          },
        );
      }

      const lemma = new Lemma({
        value: value.trim(),
        annotations: annotation
          ? annotation.split(';').map(trim).map(Annotation.fromString)
          : undefined,
      });

      group.lemmas.push(lemma);
      return acc;
    },
    [],
  );

  return synset;
}

type GroupItem = {
  index: number;
  value: string;
};

function smartSplit(value: string, isPhrase: boolean): GroupItem[] {
  if (isPhrase) {
    return value.split(';').map(toValueIndexed);
  }

  const hasSemicolon = value.indexOf(';') >= 0;
  const hasComma = value.indexOf(',') >= 0;

  if (hasSemicolon && hasComma) {
    return value.split(';').map(semiColonGroupSplit).flat(1);
  }

  return value.split(hasComma ? ',' : ';').map(toValue);
}

function semiColonGroupSplit(words: string, index: number): GroupItem[] {
  const result: GroupItem[] = [];
  for (const value of words.split(',')) {
    result.push({ value: value.trim(), index });
  }

  return result;
}

function trim(s: string): string {
  return s.trim();
}

function toValue(value: string): GroupItem {
  return { value: value.trim(), index: 0 };
}

function toValueIndexed(value: string, index: number): GroupItem {
  return { value: value.trim(), index };
}
