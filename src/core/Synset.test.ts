import { Synset } from './Synset';
import LemmaGroup from './LemmaGroup';
import Lemma from './Lemma';
import { Annotation } from './Annotation';

describe('Synset', () => {
  describe('when created', () => {
    describe('with no options', () => {
      it('should contain no groups', () => {
        expect(anEmptySynset().groups).toEqual([]);
      });

      it('should report itself as autogenerated', () => {
        expect(anEmptySynset().meta.autogenerated).toBe(true);
      });

      it('should not report itself as debatable', () => {
        expect(anEmptySynset().meta.debatable).toBe(false);
      });
    });

    describe('with options', () => {
      it('should contain those groups', () => {
        const { synset, groups } = aComplexSynset();
        expect(synset.groups).toEqual(groups);
      });

      it('should contain meta.autogenerated', () => {
        const { synset, meta } = aComplexSynset();
        expect(synset.meta.autogenerated).toBe(meta.autogenerated);
      });

      it('should contain meta.debatable', () => {
        const { synset, meta } = aComplexSynset();
        expect(synset.meta.debatable).toBe(meta.debatable);
      });
    });
  });

  describe('.lemmas()', () => {
    it('should iterate over lemmas across groups', () => {
      const { lemmas, synset } = aComplexSynset();
      expect([...synset.lemmas()]).toEqual(lemmas);
    });
  });

  describe('.annotations()', () => {
    it('should iterate over annotations across all lemmas', () => {
      const { annotations, synset } = aComplexSynset();
      expect([...synset.annotations()]).toEqual(annotations);
    });
  });

  describe('when stringified', () => {
    it('should prepend ! if it is autogenerated', () => {
      const { synset } = aComplexSynset();
      synset.meta.autogenerated = true;
      synset.meta.debatable = false;

      expect(`${synset}`).toMatch(/^!/);
    });

    it('should not prepend ! if it is not autogenerated', () => {
      const { synset } = aComplexSynset();
      synset.meta.autogenerated = false;
      synset.meta.debatable = false;

      expect(`${synset}`).not.toMatch(/^!/);
    });

    it('should prepend # if it is debatable', () => {
      const { synset } = aComplexSynset();
      synset.meta.debatable = true;
      synset.meta.autogenerated = false;

      expect(`${synset}`).toMatch(/^#/);
    });

    it('should not prepend # if it is not debatable', () => {
      const { synset } = aComplexSynset();
      synset.meta.debatable = false;
      synset.meta.autogenerated = false;

      expect(`${synset}`).not.toMatch(/^#/);
    });

    it('should prepend both !# if it is autogenerated and debatable', () => {
      const { synset } = aComplexSynset();
      synset.meta.autogenerated = true;
      synset.meta.debatable = true;

      expect(`${synset}`).toMatch(/^#!/);
    });

    it('should separate groups with (;) and lemmas with (,) inside', () => {
      const { synset, lemmas, annotations } = aComplexSynset();
      const [l1, l2, l3] = lemmas.map((l) => l.value);
      const [a1, a2] = annotations.map((a) => a.value);

      synset.meta.autogenerated = false;
      synset.meta.debatable = false;

      expect(`${synset}`).toBe(`${l1}, ${l2} (${a1}); ${l3} (${a2})`);
    });
  });

  function aComplexSynset() {
    const annotation1 = new Annotation({ value: 'obsolete' });
    const annotation2 = new Annotation({ value: 'medical' });
    const lemma1 = new Lemma({ value: 'you' });
    const lemma2 = new Lemma({ value: 'thou', annotations: [annotation1] });
    const lemma3 = new Lemma({ value: 'lupus', annotations: [annotation2] });
    const groups = [
      new LemmaGroup({ lemmas: [lemma1, lemma2] }),
      new LemmaGroup({ lemmas: [lemma3] }),
    ];

    const autogenerated = false;
    const debatable = true;

    return {
      synset: new Synset({ groups, debatable, autogenerated }),
      meta: {
        autogenerated,
        debatable,
      },
      groups,
      lemmas: [lemma1, lemma2, lemma3],
      annotations: [annotation1, annotation2],
    };
  }

  function anEmptySynset() {
    return new Synset();
  }
});
